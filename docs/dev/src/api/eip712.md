# EIP-712 Implementation

The EIP-712 module provides a complete implementation of Ethereum Improvement Proposal 712 for typed structured data signing. This ensures compatibility with Ethereum wallets and smart contracts.

## Overview

EIP-712 provides:
- **Structured Data Signing**: Type-safe message signing
- **Domain Separation**: Prevents signature reuse across applications
- **Human-Readable**: Wallet displays show structured data
- **Smart Contract Compatible**: Verifiable on-chain
- **Replay Protection**: Built-in domain and message typing

## Core Concepts

### Domain Separator

The domain separator ensures signatures are unique to your application:

```rust
use lloom_core::eip712::{Eip712Domain, domain_separator};

// Lloom's domain configuration
pub const LLOOM_DOMAIN: Eip712Domain = Eip712Domain {
    name: "Lloom Network",
    version: "1.0.0", 
    chain_id: 1, // Ethereum mainnet
    verifying_contract: None, // Can be set to contract address
    salt: None,
};

// Calculate domain separator hash
let separator = domain_separator(&LLOOM_DOMAIN);
println!("Domain separator: 0x{}", hex::encode(separator));
```

### Type Definitions

Define structured types for signing:

```rust
use lloom_core::eip712::{TypeDefinition, MemberType};

// Define the LlmRequest type
let llm_request_type = TypeDefinition {
    name: "LlmRequest",
    members: vec![
        MemberType { name: "model", type_name: "string" },
        MemberType { name: "prompt", type_name: "string" },
        MemberType { name: "systemPrompt", type_name: "string" },
        MemberType { name: "maxTokens", type_name: "uint32" },
        MemberType { name: "temperature", type_name: "uint32" },
        MemberType { name: "executorAddress", type_name: "address" },
        MemberType { name: "inboundPrice", type_name: "uint256" },
        MemberType { name: "outboundPrice", type_name: "uint256" },
        MemberType { name: "nonce", type_name: "uint64" },
        MemberType { name: "deadline", type_name: "uint64" },
    ],
};
```

## Message Encoding

### Encoding Typed Data

Encode structured data for signing:

```rust
use lloom_core::eip712::{encode_typed_data, TypedData};
use std::collections::HashMap;

// Create typed data
let typed_data = TypedData {
    domain: LLOOM_DOMAIN,
    primary_type: "LlmRequest".to_string(),
    types: HashMap::from([
        ("EIP712Domain".to_string(), vec![
            MemberType { name: "name", type_name: "string" },
            MemberType { name: "version", type_name: "string" },
            MemberType { name: "chainId", type_name: "uint256" },
        ]),
        ("LlmRequest".to_string(), llm_request_type.members),
    ]),
    message: serde_json::json!({
        "model": "gpt-3.5-turbo",
        "prompt": "Hello, world!",
        "systemPrompt": "",
        "maxTokens": 100,
        "temperature": 7000, // 0.7 * 10000
        "executorAddress": "0x742d35Cc6634C0532925a3b8D404cB8b3d3A5d3a",
        "inboundPrice": "500000000000000",
        "outboundPrice": "1000000000000000",
        "nonce": 1,
        "deadline": 1234567890,
    }),
};

// Encode for signing
let encoded = encode_typed_data(&typed_data)?;
```

### Hash Calculation

Calculate EIP-712 compliant hashes:

```rust
use lloom_core::eip712::{hash_struct, encode_data, calculate_type_hash};

// Calculate type hash
let type_hash = calculate_type_hash(
    "LlmRequest(string model,string prompt,string systemPrompt,uint32 maxTokens,uint32 temperature,address executorAddress,uint256 inboundPrice,uint256 outboundPrice,uint64 nonce,uint64 deadline)"
);

// Encode data
let encoded_data = encode_data(&typed_data)?;

// Calculate struct hash
let struct_hash = hash_struct(&type_hash, &encoded_data);

// Final message hash (what gets signed)
let message_hash = keccak256(&encode_packed(&[
    "\x19\x01".as_bytes(),
    &domain_separator(&LLOOM_DOMAIN),
    &struct_hash,
]));
```

## Type Registry

### Registering Types

Register custom types for reuse:

```rust
use lloom_core::eip712::{TypeRegistry, register_type};

let mut registry = TypeRegistry::new();

// Register standard types
registry.register("LlmRequest", llm_request_type);
registry.register("LlmResponse", llm_response_type);
registry.register("UsageRecord", usage_record_type);

// Register nested types
let nested_type = TypeDefinition {
    name: "ModelConfig",
    members: vec![
        MemberType { name: "name", type_name: "string" },
        MemberType { name: "version", type_name: "string" },
        MemberType { name: "capabilities", type_name: "string[]" },
    ],
};
registry.register("ModelConfig", nested_type);

// Use in other types
let advanced_request = TypeDefinition {
    name: "AdvancedRequest",
    members: vec![
        MemberType { name: "config", type_name: "ModelConfig" },
        MemberType { name: "request", type_name: "LlmRequest" },
    ],
};
```

### Type Validation

Validate type definitions:

```rust
use lloom_core::eip712::{validate_type, TypeValidationError};

match validate_type(&type_definition) {
    Ok(()) => println!("Type is valid"),
    Err(TypeValidationError::InvalidTypeName(name)) => {
        eprintln!("Invalid type name: {}", name);
    }
    Err(TypeValidationError::DuplicateMember(member)) => {
        eprintln!("Duplicate member: {}", member);
    }
    Err(TypeValidationError::UnknownType(type_name)) => {
        eprintln!("Unknown type referenced: {}", type_name);
    }
}
```

## Implementation Details

### LlmRequest Implementation

Full implementation for LlmRequest:

```rust
use lloom_core::eip712::{Eip712, Eip712Domain, hash_struct};
use alloy::sol_types::SolStruct;

// Define the Solidity struct
sol! {
    struct LlmRequestCommitment {
        address executor;
        string model;
        bytes32 promptHash;
        bytes32 systemPromptHash;
        uint32 maxTokens;
        uint32 temperature;
        uint256 inboundPrice;
        uint256 outboundPrice;
        uint64 nonce;
        uint64 deadline;
    }
}

impl Eip712 for LlmRequestCommitment {
    const NAME: &'static str = "LlmRequestCommitment";
    
    const TYPE_HASH: [u8; 32] = keccak256!(
        "LlmRequestCommitment(address executor,string model,bytes32 promptHash,bytes32 systemPromptHash,uint32 maxTokens,uint32 temperature,uint256 inboundPrice,uint256 outboundPrice,uint64 nonce,uint64 deadline)"
    );
    
    fn domain() -> Eip712Domain {
        LLOOM_DOMAIN
    }
    
    fn encode_data(&self) -> Vec<u8> {
        let mut encoded = Vec::new();
        encoded.extend_from_slice(&Self::TYPE_HASH);
        encoded.extend_from_slice(&self.executor.encode());
        encoded.extend_from_slice(&keccak256(self.model.as_bytes()));
        encoded.extend_from_slice(&self.promptHash);
        encoded.extend_from_slice(&self.systemPromptHash);
        encoded.extend_from_slice(&self.maxTokens.encode());
        encoded.extend_from_slice(&self.temperature.encode());
        encoded.extend_from_slice(&self.inboundPrice.encode());
        encoded.extend_from_slice(&self.outboundPrice.encode());
        encoded.extend_from_slice(&self.nonce.encode());
        encoded.extend_from_slice(&self.deadline.encode());
        encoded
    }
    
    fn struct_hash(&self) -> [u8; 32] {
        keccak256(&self.encode_data())
    }
}
```

### Custom Type Implementation

Implement EIP-712 for custom types:

```rust
use lloom_core::eip712::{Eip712Type, DynamicEip712};

#[derive(Eip712Type)]
#[eip712(name = "CustomMessage", domain = "LLOOM_DOMAIN")]
struct CustomMessage {
    #[eip712(type = "string")]
    message: String,
    
    #[eip712(type = "uint256")]
    value: U256,
    
    #[eip712(type = "address")]
    recipient: Address,
    
    #[eip712(type = "bytes32[]")]
    proof: Vec<[u8; 32]>,
}

// Or implement manually
impl Eip712 for CustomMessage {
    const NAME: &'static str = "CustomMessage";
    
    const TYPE_HASH: [u8; 32] = keccak256!(
        "CustomMessage(string message,uint256 value,address recipient,bytes32[] proof)"
    );
    
    fn encode_data(&self) -> Vec<u8> {
        let mut encoded = Vec::new();
        encoded.extend_from_slice(&Self::TYPE_HASH);
        encoded.extend_from_slice(&keccak256(self.message.as_bytes()));
        encoded.extend_from_slice(&self.value.encode());
        encoded.extend_from_slice(&self.recipient.encode());
        // For arrays, encode as keccak256 of concatenated elements
        let proof_encoded: Vec<u8> = self.proof.iter()
            .flat_map(|p| p.as_slice())
            .copied()
            .collect();
        encoded.extend_from_slice(&keccak256(&proof_encoded));
        encoded
    }
}
```

## Advanced Features

### Nested Types

Handle complex nested structures:

```rust
use lloom_core::eip712::{NestedType, encode_nested};

#[derive(Eip712Type)]
struct Order {
    #[eip712(type = "OrderDetails")]
    details: OrderDetails,
    
    #[eip712(type = "Payment")]
    payment: Payment,
}

#[derive(Eip712Type)]
struct OrderDetails {
    #[eip712(type = "string")]
    item_id: String,
    
    #[eip712(type = "uint256")]
    quantity: U256,
}

#[derive(Eip712Type)]
struct Payment {
    #[eip712(type = "address")]
    token: Address,
    
    #[eip712(type = "uint256")]
    amount: U256,
}

// Encode nested structure
let order = Order {
    details: OrderDetails {
        item_id: "ITEM-123".to_string(),
        quantity: U256::from(10),
    },
    payment: Payment {
        token: token_address,
        amount: U256::from(1000),
    },
};

let encoded = order.encode_eip712()?;
```

### Dynamic Types

Handle dynamic type generation:

```rust
use lloom_core::eip712::{DynamicType, TypeBuilder};

// Build type at runtime
let dynamic_type = TypeBuilder::new("DynamicMessage")
    .add_member("id", "uint256")
    .add_member("data", "bytes")
    .add_member("timestamps", "uint64[]")
    .add_member("authorized", "address[]")
    .build()?;

// Create dynamic message
let message = DynamicEip712::new(dynamic_type)
    .set("id", U256::from(123))
    .set("data", Bytes::from(vec![1, 2, 3, 4]))
    .set("timestamps", vec![1234567890u64, 1234567891])
    .set("authorized", vec![addr1, addr2])
    .build()?;

// Sign dynamic message
let signature = sign_dynamic_eip712(&message, &signer)?;
```

### Permit Pattern

Implement EIP-2612 style permits:

```rust
use lloom_core::eip712::{Permit, PERMIT_TYPEHASH};

#[derive(Eip712Type)]
#[eip712(name = "Permit", domain = "LLOOM_DOMAIN")]
struct Permit {
    #[eip712(type = "address")]
    owner: Address,
    
    #[eip712(type = "address")]
    spender: Address,
    
    #[eip712(type = "uint256")]
    value: U256,
    
    #[eip712(type = "uint256")]
    nonce: U256,
    
    #[eip712(type = "uint256")]
    deadline: U256,
}

// Create permit
let permit = Permit {
    owner: owner_address,
    spender: spender_address,
    value: U256::MAX, // Unlimited approval
    nonce: U256::from(0),
    deadline: U256::from(deadline_timestamp),
};

// Sign permit
let signature = permit.sign_eip712(&owner_wallet)?;

// Use in contract call
contract.permit(
    permit.owner,
    permit.spender,
    permit.value,
    permit.deadline,
    signature.v,
    signature.r,
    signature.s,
)?;
```

## Wallet Integration

### MetaMask Compatibility

Format for MetaMask signing:

```rust
use lloom_core::eip712::{format_for_metamask, MetaMaskRequest};

let metamask_request = format_for_metamask(&typed_data)?;

// Send to MetaMask via JSON-RPC
let signature = ethereum_provider.request({
    method: "eth_signTypedData_v4",
    params: [signer_address, metamask_request],
})?;
```

### WalletConnect Support

Integrate with WalletConnect:

```rust
use lloom_core::eip712::{WalletConnectFormatter, SigningRequest};

let formatter = WalletConnectFormatter::new();
let signing_request = formatter.create_request(
    &typed_data,
    &signer_address
)?;

// Send via WalletConnect
let signature = wallet_connect_client
    .request(signing_request)
    .await?;
```

## Verification

### On-Chain Verification

Verify signatures in smart contracts:

```solidity
// Solidity contract
contract LloomVerifier {
    bytes32 constant DOMAIN_TYPEHASH = keccak256(
        "EIP712Domain(string name,string version,uint256 chainId)"
    );
    
    bytes32 constant REQUEST_TYPEHASH = keccak256(
        "LlmRequest(address executor,string model,bytes32 promptHash,uint32 maxTokens,uint64 nonce,uint64 deadline)"
    );
    
    bytes32 immutable DOMAIN_SEPARATOR;
    
    constructor() {
        DOMAIN_SEPARATOR = keccak256(abi.encode(
            DOMAIN_TYPEHASH,
            keccak256("Lloom Network"),
            keccak256("1.0.0"),
            block.chainid
        ));
    }
    
    function verify(
        LlmRequest memory request,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public view returns (address) {
        bytes32 structHash = keccak256(abi.encode(
            REQUEST_TYPEHASH,
            request.executor,
            keccak256(bytes(request.model)),
            request.promptHash,
            request.maxTokens,
            request.nonce,
            request.deadline
        ));
        
        bytes32 digest = keccak256(abi.encodePacked(
            "\x19\x01",
            DOMAIN_SEPARATOR,
            structHash
        ));
        
        return ecrecover(digest, v, r, s);
    }
}
```

### Off-Chain Verification

Verify in Rust:

```rust
use lloom_core::eip712::{verify_eip712_signature, recover_eip712_signer};

// Verify signature matches expected signer
let is_valid = verify_eip712_signature(
    &typed_data,
    &signature,
    &expected_signer
)?;

// Or recover signer
let signer = recover_eip712_signer(
    &typed_data,
    &signature
)?;
```

## Testing

### Test Utilities

Generate test data:

```rust
#[cfg(test)]
mod tests {
    use lloom_core::eip712::test_utils::*;
    
    #[test]
    fn test_eip712_signing() {
        // Generate test typed data
        let typed_data = generate_test_typed_data();
        
        // Create test signer
        let signer = test_signer();
        
        // Sign
        let signature = sign_typed_data(&typed_data, &signer)?;
        
        // Verify
        assert!(verify_typed_data_signature(
            &typed_data,
            &signature,
            &signer.address()
        )?);
    }
}
```

### Compliance Testing

Verify EIP-712 compliance:

```rust
use lloom_core::eip712::compliance::{test_eip712_compliance, ComplianceReport};

let report = test_eip712_compliance(&my_type)?;
println!("Compliance report:");
println!("  Valid type hash: {}", report.valid_type_hash);
println!("  Correct encoding: {}", report.correct_encoding);
println!("  Domain compliant: {}", report.domain_compliant);

assert!(report.is_compliant());
```

## Best Practices

1. **Domain Configuration**
   - Use unique domain name
   - Include chain ID
   - Consider adding contract address
   - Version your domain

2. **Type Safety**
   - Define types explicitly
   - Use type registry for consistency
   - Validate types before use
   - Document type changes

3. **Security**
   - Always verify domain separator
   - Check message expiry
   - Implement replay protection
   - Validate all fields

4. **Compatibility**
   - Test with multiple wallets
   - Follow EIP-712 spec exactly
   - Use standard type names
   - Provide clear signing prompts

5. **Gas Optimization**
   - Pre-compute type hashes
   - Cache domain separator
   - Minimize dynamic strings
   - Use efficient encodings